<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>noc的手记</title>
  
  <subtitle>hello world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://noncover.github.io/"/>
  <updated>2020-05-18T12:30:51.008Z</updated>
  <id>https://noncover.github.io/</id>
  
  <author>
    <name>NonCover</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拓扑排序真的很简单</title>
    <link href="https://noncover.github.io/2020/05/18/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/"/>
    <id>https://noncover.github.io/2020/05/18/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/</id>
    <published>2020-05-18T11:02:00.000Z</published>
    <updated>2020-05-18T12:30:51.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是拓扑排序"><a href="#什么是拓扑排序" class="headerlink" title="什么是拓扑排序"></a>什么是拓扑排序</h1><p>说拓扑排序之前，先来说一下为什么要有拓扑排序，假设，我们有一份课程表。我们学当前课程的时候，必须要满足学完某些课程的条件，才能学当前课程，我们把这种满足条件称为先决条件，用一张表表示如下：</p><table><thead><tr><th align="left">ID</th><th align="left">课程名</th><th align="left">先决条件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">高数</td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">计算机</td><td align="left">高数</td></tr><tr><td align="left">3</td><td align="left">数据库</td><td align="left">计算机、英语</td></tr><tr><td align="left">4</td><td align="left">英语</td><td align="left">高数</td></tr></tbody></table><p>我们再把表抽象成图，就能够直观感受到课程之间的联系：</p><p><img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589786889237.png" alt="img"></p><p>再来看图，就能够看出每个课程之间的关系，如何学习每门课程的顺序就能够轻而易举得出来</p><blockquote><p>1 -&gt; 2 -&gt; 4 -&gt; 3</p><p>1 -&gt; 4 -&gt; 2 -&gt; 3</p></blockquote><p>该顺序得出过程我们把它称之为拓扑排序，注意拓扑排序的结果并不是唯一的。</p><p>拓扑排序必须满足以下规则：</p><ul><li>每个节点是唯一的</li><li>图中不能存在环结构</li></ul><p>这篇文章主要介绍两种常用的拓扑结构算法，以及如何用Python代码实现。</p><h1 id="DFS（推荐）"><a href="#DFS（推荐）" class="headerlink" title="DFS（推荐）"></a>DFS（推荐）</h1><p>看到DFS，我们应该首先想到用队列实现，队列的基本实现满足先进先出原理，那么我们如何初始化队列呢，在一个有向图中，必定有一些节点是没有任何节点指向它的，也就是这些节点的<strong>入度</strong>为0，其实我们可以理解成这些课程是没有任何先决条件就可以学习的，所以把这些课程直接加入到队列queue中，我们用几组图片来模拟一下算法实现的过程。</p><blockquote><p>把入度为0的节点入队</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589791727155.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>1出队，同时加入结果数组中，并且1所指向的节点入度减一，当入度为0时，别忘了入队</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589791830906.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>重复以上过程直到队列为空</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589791968968.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589792021713.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589792044647.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>最后当队列为空时，我们返回答案即可（<strong>注意我们需要判断结果数组中节点是否全部存在，否则的话说明图中存在环结构</strong>）</p></blockquote><p>基本思路如下：</p><ul><li>入度为0的入队</li><li>出队的同时，需要同时把节点加入answer中</li><li>我们需要把出队的节点指向的节点的入度减一，如果为0时需要入队</li></ul><p>我们来看一些代码组成</p><p>由于图是一种较复杂的数据结构，我们用Python集合类中的字典实现</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">edeges = collections.defaultdict(list)</span><br><span class="line">edeges[<span class="number">1</span>] = [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">edeges[<span class="number">2</span>] = [<span class="number">3</span>]</span><br><span class="line">edeges[<span class="number">4</span>] = [<span class="number">3</span>]</span><br><span class="line">nums = <span class="number">4</span>    <span class="comment">## 节点个数</span></span><br></pre></td></tr></tbody></table></figure><p>接下来就是用数组<code>in_degree</code>来存放每个节点的入度。下标对于节点，值对应的是入度。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in_degree = [<span class="number">0</span>] * (nums + <span class="number">1</span>)    <span class="comment">## 初始化入度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nums + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> edeges[i]:</span><br><span class="line">        in_degree[j] += <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>然后就是整个算法最重要的DFS的实现了，首先初始化队列用双端队列实现</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue = collections.deque(</span><br><span class="line">    [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nums) <span class="keyword">if</span> in_degree[i] == <span class="number">0</span>]</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>整个算法流程如下</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res = []    <span class="comment">## 存放结果</span></span><br><span class="line"><span class="keyword">while</span> queue:    </span><br><span class="line">    curr = queue.popleft()    </span><br><span class="line">    res.append(curr)    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> edeges[curr]:        </span><br><span class="line">        <span class="comment">## 当前节点指向的所有的节点的入度减一        </span></span><br><span class="line">        in_degree[i] -= <span class="number">1</span>        </span><br><span class="line">        <span class="keyword">if</span> in_degree[i] == <span class="number">0</span>: </span><br><span class="line">            queue.append(i)</span><br></pre></td></tr></tbody></table></figure><p>当然，最后别忘了判断是否有环</p><p>在这里我推荐用DFS，个人觉得DFS比起BFS好理解，但我还是讲一下BFS，讲得不好请见谅。</p><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>DFS是队列实现，那么BFS肯定是用栈实现，既然用到了栈，那我们肯定要明白，我们会把一个路走到底，然后再走另一条路。</p><p>再回看上图，我们要先学1，然后才能学2和4，最后才能学3。</p><p>如果是按照BFS思路的话，我们如何来判断图是否存在环结构呢？DFS之所以能够判断环结构是用入度来判断的，因为在一个环结构中，入度是无法成为0的，所以不能够成功入队。而BFS并不能用入度来判断，因为BFS算法是线性搜索每一节点，所以我们需要用标记法来判断。</p><p>对于一个节点，<strong>0 代表没有检查，1代表检查过，2代表检查完毕已加入答案中</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 一个数组来保存一个节点是否访问过，0 = 为访问 1 = 访问过 2 = 访问完毕</span></span><br><span class="line">seen = [<span class="number">0</span>] * (nums + <span class="number">1</span>)</span><br><span class="line">res = [] <span class="comment">## 存放拓扑排序结果</span></span><br><span class="line"><span class="comment">## 递归实现（栈空间）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span>    </span><br><span class="line">    <span class="comment">## 访问过，说明有环    </span></span><br><span class="line">    <span class="keyword">if</span> seen[i] == <span class="number">1</span>:        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>    </span><br><span class="line">    <span class="comment">## 访问完毕，直接返回    </span></span><br><span class="line">    <span class="keyword">if</span> seen[i] == <span class="number">2</span>:        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>   </span><br><span class="line">    <span class="comment">## 没有访问，设为访问    </span></span><br><span class="line">    seen[i] = <span class="number">1</span>    </span><br><span class="line">    <span class="comment">## 将当前节点加入到栈中，相当于调用dfs    </span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> edeges[i]:        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dfs(e):            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>    </span><br><span class="line">        <span class="comment">## 访问完毕    </span></span><br><span class="line">    seen[i] = <span class="number">2</span>    </span><br><span class="line">    <span class="comment">## 加入到答案数组中去    </span></span><br><span class="line">    res.append(i)    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nums + <span class="number">1</span>):    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> dfs(i):        </span><br><span class="line">        <span class="string">"""如果存在环就无法进行拓扑排序"""</span>        </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></tbody></table></figure><p>我们每次进行dfs时，首先检查该节点的标记码是不是1，是的话就存在环。</p><p>老规矩，图解算法，方便理解</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589795570993.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>首先，节点1入栈，标记为1，然后继续dfs。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589795779844.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>直到dfs（3）的时候，此时，再无可递归节点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589795841639_3zczFxH.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>再看代码，此时不存在环结构，我们就开始出栈，并且将标识码记为2</p><p><img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589796176439_zxu6RKe.png" alt=""></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589796197717.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>此时，节点1还有一条路，可以走。</p><p>由于节点3已经处理过，所以直接返回True，出栈。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589796336485.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589796369490.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/18/1589796399793.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>DFS算法流程就如上，此时res = [3, 2, 4, 1]，由于stack先进后出，所以只需要对res取反就可以得到正确答案。</p><p>获取完整代码可以看一下我的<a href="https://github.com/NonCover/Algorithms/tree/master/拓扑排序" target="_blank" rel="noopener">github仓库</a>，感兴趣的可以点个star。</p><p>感谢，如果文章有错，欢迎赐教，如果你有感悟，点个赞。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是拓扑排序&quot;&gt;&lt;a href=&quot;#什么是拓扑排序&quot; class=&quot;headerlink&quot; title=&quot;什么是拓扑排序&quot;&gt;&lt;/a&gt;什么是拓扑排序&lt;/h1&gt;&lt;p&gt;说拓扑排序之前，先来说一下为什么要有拓扑排序，假设，我们有一份课程表。我们学当前课程的时候，必须要满
      
    
    </summary>
    
    
      <category term="算法" scheme="https://NonCover.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://NonCover.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="图" scheme="https://NonCover.github.io/tags/%E5%9B%BE/"/>
    
      <category term="Python" scheme="https://NonCover.github.io/tags/Python/"/>
    
      <category term="dfs" scheme="https://NonCover.github.io/tags/dfs/"/>
    
      <category term="bfs" scheme="https://NonCover.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>位运算知识点总结</title>
    <link href="https://noncover.github.io/2020/05/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://noncover.github.io/2020/05/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-14T04:12:58.000Z</published>
    <updated>2020-05-14T04:14:27.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>任何一台计算机内部保存的是二进制，再进行逻辑运算和算术运算的时候，计算机只会对二进制执行运算，而计算机对二进制执行的运算叫做位运算。</p><p>举例说明，计算机执行3 + 5是如何计算的。</p><p>3： 0 0 0 0  0 0 1 1 </p><p>5： 0 0 0 0  0 1 0 1</p><p>8： 0 0 0 0  1 0 0 0   </p><p> 就这样讲十进制转换成二进制后，执行简单的0，1计算，我们平时再写代码的时候常用的运算符为（+，-，*，/，%），但是如何我们能合理的使用位运算，将很大程度上提高我们代码执行的效率。</p><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><table><thead><tr><th align="center">符号</th><th align="center">名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><strong>&amp;</strong></td><td align="center">与</td><td align="center">都为1，才为1</td></tr><tr><td align="center"><strong>|</strong></td><td align="center">或</td><td align="center">有一个1，都可以为1</td></tr><tr><td align="center"><strong>^</strong></td><td align="center">异或</td><td align="center">相同为0，不同为1</td></tr><tr><td align="center"><strong>~</strong></td><td align="center">取反</td><td align="center">1变为0，0变为1</td></tr><tr><td align="center"><strong>&lt;&lt;</strong></td><td align="center">左移</td><td align="center">所有位向左移动若干位，高位溢出丢弃，低位补0</td></tr><tr><td align="center"><strong>&gt;&gt;</strong></td><td align="center">右移</td><td align="center">所有位向左移动若干位，分有符号位和无符号位</td></tr></tbody></table><h1 id="按位与（-amp-）"><a href="#按位与（-amp-）" class="headerlink" title="按位与（&amp;）"></a>按位与（&amp;）</h1><p>先看与运算逻辑：</p><p>1 &amp; 1 = 1， 1 &amp; 0 = 0， 0 &amp; 1= 0， 0 &amp; 0 = 0</p><p>当第一个数为0时，此时形成断路，剩下的表达式不会执行，程序就会输出0</p><blockquote><p>input: 2 &amp; 2</p><p>output: 2</p><p>input: 2 &amp; 0</p><p>output: 0</p></blockquote><p>总结规律：</p><ol><li><p>任何一个数与其本身与为其本身，与0与为0</p></li><li><p>另外通过与运算，我们可以知道一个数是否是奇数还是偶数。</p><blockquote><p>奇数 &amp; 1 = 1</p><p>偶数 &amp; 1 = 0</p></blockquote></li></ol><h1 id="按位或（-）"><a href="#按位或（-）" class="headerlink" title="按位或（|）"></a>按位或（|）</h1><p>运算逻辑：</p><p>1 | 1 = 1，1 | 0 = 1，0 | 1 = 1，0 | 0 = 0</p><p>注意：负数的或运算按它的<strong>补码</strong>进行运算（负数的补码 = 原码取反 + 1）</p><h1 id="按位异或（-）"><a href="#按位异或（-）" class="headerlink" title="按位异或（^）"></a>按位异或（^）</h1><p>运算逻辑：</p><p>1 ^ 1 = 0，1 ^ 0 = 1,  0 ^ 1 = 1,  0 ^ 0 = 0</p><p>总结：</p><ol><li>参加运算的两个数相同的话为0</li><li>任何一个数与0进行异或为其本身</li></ol><p>异或满足以下几个性质：</p><ul><li>交换律：a ^ b = b ^ a</li><li>结合律：a ^ (b ^ c) = (a ^ b) ^ c</li><li>自反性：a ^ b ^ b =  a ^ 0 = a</li><li>a ^ a = 0, a ^ 0 = a</li></ul><p>同样，异或运算还能够交换两个数，再没有第三个数的情况下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h1><p>运算逻辑：</p><p>~1 = 0, ~0 = 1</p><p>如果我们再IDE中编译的话，我们会发现~1 = -2, ~0 = -1。</p><p>what？这是怎么一回事，不是取反嘛，怎么会成这种结果。</p><p>其实上面的结果并没有错，我们一步一步来看。</p><p>我们假设都为八位二进制。</p><p>1： 0000 0001</p><p>取反的结果为：1111 1110，此时这个数为负数是以补码的形式保存在计算机内部中的，我们取它的原码为：1000 0010，最高位为符号位，此时为负。</p><p>所以最终结果为-2。</p><p> 我们在来看负数如何取反，</p><p>例如：~-2 = 1是如何得来得</p><p>要知道计算机保存负数是保存的它的补码。</p><p>-2 ：1000 0010</p><p>补码：1111 1110</p><p>此时再取反：0000 0001此时为正数</p><p>取原码：0000 0001（正数的补码=原码），所以最终结果为1</p><p>说到这，我们再来说一下负数的补码怎么计算：</p><blockquote><p>X补 = ~X原 + 1 (原码取反加1，符号为不变) </p></blockquote><p>正数的原码=反码=补码</p><h1 id="左移（-lt-lt-）"><a href="#左移（-lt-lt-）" class="headerlink" title="左移（<<）"></a>左移（&lt;&lt;）</h1><p>运算逻辑：</p><p>正数的左移，例如int32位正数，把每一位向左移动若干位，最左边的位丢弃若干位，最右边的补上若干0</p><p>负数的话，由于最高位是1，所以最高位保持不变，左边舍弃若干个，除了最高位，右边补若干个0即可</p><p>例如 a = 1000 0110（-6）    a &lt;&lt; 1 = 1000 11 00（-12）</p><p>其实我们可以发现，左移实际上就是 <strong>a * 2的左移多少位次方</strong>，</p><h1 id="右移（-gt-gt-）"><a href="#右移（-gt-gt-）" class="headerlink" title="右移（>>）"></a>右移（&gt;&gt;）</h1><p>运算逻辑:</p><p>正数的右移若干位，只需要左边补上若干个0，右边舍弃若干个即可。</p><p>负数的右移若干位，只需左边不上若干个1，右边舍弃若干个。</p><blockquote><p>5 &gt;&gt; 1 = 2</p><p>5 &gt;&gt; 2 = 1</p></blockquote><p>右移多少位，相当于除于2的多少位次方。</p><p>不过需要注意的是，我们有些编程语言处理情况不一样。</p><p>在Java中，-3 &gt;&gt; 1 = -2,  -3 / 2 = -1</p><p>但是在Python中，-3 &gt;&gt; 1 = -2, -3 // 2 = -2。</p><p>不过右移运算得出的答案都遵循计算机运算规则，但是除法的话是按照解释器的处理而言。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>位运算到此为止，我们再写代码的时候其实可以把某些运算写成位运算更能题高效率。</p><ol><li><p>判断x的奇偶数</p><blockquote><p>x % 2 == 1 // 常规写法</p><p>x &amp; 1 == 1 // 为真奇数，为假偶数 </p></blockquote></li><li><p>计算中位数</p><blockquote><p>mid = (left + right) / 2  // 常规写法</p><p>mid  = (left + right) &gt;&gt; 1 // 位运算</p></blockquote></li><li><p>交换两个数</p><blockquote><p>a ^= b</p><p>b ^= a</p><p>a ^= b</p></blockquote></li></ol><p>总结到此，欢迎补充</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;任何一台计算机内部保存的是二进制，再进行逻辑运算和算术运算的时候，计算机只会对二进制执行运算，而计算机对二进制执行的运算叫做位运算。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://NonCover.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="位运算" scheme="https://NonCover.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="数码" scheme="https://NonCover.github.io/tags/%E6%95%B0%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>啥？我写了个服务器</title>
    <link href="https://noncover.github.io/2020/05/13/%E5%95%A5%EF%BC%9F%E6%88%91%E5%86%99%E4%BA%86%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://noncover.github.io/2020/05/13/%E5%95%A5%EF%BC%9F%E6%88%91%E5%86%99%E4%BA%86%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-05-13T08:19:40.000Z</published>
    <updated>2020-05-13T08:27:15.279Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没想到我也是一个标题党</p></blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>去年，利用业余时间以及所学知识建了人生中<a href="http://lock2016.xyz/" target="_blank" rel="noopener">第一个网站</a>，这个网站也就我用来平时写写东西。当然前期就是写后端交互代码，把后端代码写好的话，免不了要放在服务器上，既然放在服务器上，我们肯定也要部署Web服务器，目前市面上常用的两款Web服务器就是apache和NginX，在我了解了这两款服务器后，我坚决的选择了后者，那就是鼎鼎大名的NginX。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/13/1589347216122.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>按F12可以查看到我网站的请求头里就有我的代理服务器版本号。当然博思平台也用的是此款服务器。</p><p>总之，我们不妨先记住Nginx的几个优点，高并发，轻量级，部署简单快捷，百万级的访问量下，Nginx能够还能够保持它的性能，这也得益于它的代理策略。</p><h1 id="关于Nginx（Engine-X）"><a href="#关于Nginx（Engine-X）" class="headerlink" title="关于Nginx（Engine X）"></a>关于Nginx（Engine X）</h1><blockquote><p>nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by <a href="http://sysoev.ru/en/" target="_blank" rel="noopener">Igor Sysoev</a>. For a long time, it has been running on many heavily loaded Russian sites including <a href="http://www.yandex.ru/" target="_blank" rel="noopener">Yandex</a>, <a href="http://mail.ru/" target="_blank" rel="noopener">Mail.Ru</a>, <a href="http://vk.com/" target="_blank" rel="noopener">VK</a>, and <a href="http://www.rambler.ru/" target="_blank" rel="noopener">Rambler</a>. According to Netcraft, nginx served or proxied <a href="https://news.netcraft.com/archives/2020/04/08/april-2020-web-server-survey.html" target="_blank" rel="noopener">25.54% busiest sites in April 2020</a>. Here are some of the success stories: <a href="https://blogs.dropbox.com/tech/2017/09/optimizing-web-servers-for-high-throughput-and-low-latency/" target="_blank" rel="noopener">Dropbox</a>, <a href="https://openconnect.netflix.com/en/software/" target="_blank" rel="noopener">Netflix</a>, <a href="https://www.nginx.com/case-studies/nginx-wordpress-com/" target="_blank" rel="noopener">Wordpress.com</a>, <a href="http://blog.fastmail.fm/2007/01/04/webimappop-frontend-proxies-changed-to-nginx/" target="_blank" rel="noopener">FastMail.FM</a>.</p></blockquote><p>上面这段话出自Nginx官网，大致意思差不多就是Nginx这个服务器很多牛逼的互联网公司在用，</p><p>不过说到Nginx，那就要说到 伊戈尔·赛索耶夫 这个人，他是一名俄罗斯软件工程师，也就是Nginx的发明者，不得不说，毛子的编程水平也是一流。他在工作闲暇之余用C语言开发了这款闻名全球的轻量级高并发的Web服务器，Nginx不仅可以用作网站的服务器，还可以作为支持电子邮件的代理服务器。早期的淘宝就是用的Nginx来部署的（厉害吧），不过随着淘宝网后期的业务调整之类的种种原因，淘宝叫来了一群工程师，把Nginx的一些组件封装好，再加入一些特性，开发出了一款<strong>全新</strong>的Web服务器<strong>Tengine</strong>，估计淘宝现在用的是自家的服务器吧。</p><p>不过悲惨的是，伊戈尔·赛索耶夫在去年被俄罗斯警方逮捕，随着一起被逮捕的有另外一个人，也是Nginx的开发者之一，具体原因大家可以百度一下，为了节省篇幅就不废话了。</p><p>说到这，Nginx官网介绍的是，这款服务器是一个反向代理服务器，那么什么是反向代理？说反向代理之前，我先来说一下正向代理吧！此文的重点来了</p><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>先看一个直观图（图片来源网络）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/13/u12973693652217576409fm26gp0.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>Proxy server就是我们的代理服务器，Server就是我们需要访问的服务器</p><p>举个例子：某天小明在写代码的时候发现了一个Bug，他想上谷歌搜一下这个Bug是怎么回事，但是无论怎么搜只能搜到如下界面</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/13/1589349030919.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>后来，小明知道了学校的服务器是可以访问Google的，他就向学校的服务器发送了一个请求，学校的服务器收到了请求后，再去访问Google，随后再把Google返回的数据返回给小明，就这样小明成功的访问到了Google。</p><p>例子中很容易就理解了正向代理服务器的过程，学校的服务器就作为一个代理服务器，而Google就是我们想要访问的目标服务器，而我们是无法直接访问，只能通过代理服务器去访问，然后再把数据返回给我们。</p><p>正向代理我们是需要手动去设置代理服务器的ip地址的，在Win下就可以直接设置代理服务器，有兴趣的可以百度一下如何设置。我就不讲如何设置了。</p><p>那说完了正向代理，下面就要讲Nginx所用到的反向代理模式了。</p><p>累死我了，喝口茶<del>~</del></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/13/1.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>说到反向代理，我们先讲一下服务器群组，玩过饥荒的同学知道，如果我们自己开房间玩的话，房主所在的电脑将被饥荒作为一个服务器，所有玩家都将连接到你的电脑上来进行联机游玩，要知道当初我电脑性能并不是很好，记得一个房间最多5人还是8人来着，刚开始还好，游戏正常有序的进行下去，越到后面，随着加入游戏的人数增多，后期资源，地图的扩大，导致了我的电脑宕机了，没错直接就崩了，从那之后我就再也没有自己开过房间玩，到后面就游戏就吃灰了（哈哈，我玩游戏玩不长，总想着玩新游戏）。</p><p>不够这也说明电脑以及服务器的性能是执行程序效率的好坏关键之一。话不多说，还是先来看一图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/13/1589350583198.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>我们再思考一个问题，现实生活中，无论你的服务器性能再好，你终究只是一台服务器，然而我们却要处理数以千万记的请求，就像<a href="http://lock2016.xyz/blog/article/www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>一样，每天都会有千万ip在进行着访问服务器的过程，可一个服务器怎么可能处理的过来，这个时候反向代理服务器就出来了，例如上图，当我们去访问baidu的时候，<a href="http://lock2016.xyz/blog/article/www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>这个域名指向的服务就作为一个代理服务器，代理服务器利用一种算法（负载均衡算法，下文会讲）将每一个请求转发到其LAN下的某一台具体的服务器，接下来这台服务器处理相关的请求，随后返回给客户端。就这样简单。</p><h1 id="正-反向代理的使用场景"><a href="#正-反向代理的使用场景" class="headerlink" title="正/反向代理的使用场景"></a>正/反向代理的使用场景</h1><p>其实正向代理估计很多人都已经知晓他的用途了，没错，那就是翻墙，俗话说的好，不会翻墙的程序员不是一个好bloger，咳咳~~，当然墙外的世界很精彩，还是要告诉大家，之所以会有墙的存在，是因为国外的一些反动分子，诸如废青之类的影响到了我们祖国的新一代就不好了，当然我们翻墙看一看外面的世界也要谨慎发言才好。平时我翻墙的话用的就是ssr，俗称酸酸乳，下面我会给出软件。</p><p>那反向代理主要就是用来为一群服务器提供负载均衡，保持性能资源利用最大化。</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>本来负载均衡我是打算另开一个文章来详细说的，眼看开学在即，我也没有多少时间收集资料，这里我就简单的描述一下，以及用Java简单模拟一下负载均衡算法。</p><p>负载均衡的英语是 <strong>load balance</strong>，目的是用来使每一台服务器负载量保持均衡，比如说，我有十台服务器，我不可能让第一台服务器处理一百个请求，第二台服务器处理1个请求吧，所以就有了算法来处理这些问题。</p><p>我这里只说两种常用的负载均衡算法</p><h2 id="1-轮询法-Round-Robin"><a href="#1-轮询法-Round-Robin" class="headerlink" title="1. 轮询法(Round Robin)"></a>1. 轮询法(Round Robin)</h2><p>所谓轮询法，轮询，轮询，光听名字就知道，轮着来呗，假如我们有10台服务器，一台代理服务器，突然有10个ip发来了请求，代理服务器就把这10个请求依次交给这10台服务器，每个服务器都达到了负载均衡，只需处理一个请求即可。光听描述简单吧。我相信你能够懂，代码我就不写了，一个循环而已。</p><p>方法总是伴随着问题而来，负载是达到了均衡，可是真的达到了吗？我再举一个例子，假如有10个人，其中有高有矮，有壮有瘦，在他们的面前有1000斤的东西要搬到仓库去，如果按照轮询法的策略的话，每个人只需要搬100斤的东西，可是又高又壮的人明明可以般200斤，矮的人最多只能般50斤。这样的话就造成了资源浪费以及超负荷负载。那么接下来讲的就是另一种负载均衡算法了。</p><h2 id="2-加权轮询法-Weight-Round-Robin"><a href="#2-加权轮询法-Weight-Round-Robin" class="headerlink" title="2. 加权轮询法(Weight Round Robin)"></a>2. 加权轮询法(Weight Round Robin)</h2><p>没错，我要写代码了，之所以上面不写，主要是这两个算法不难，但是在服务器内部实现的话要考虑很多因素，待会儿再说这个问题。</p><p>其实我们只需要把每一台服务器加上一个权值，这个权的大小代表着这个服务器的性能好坏。</p><p>我们先实现一个类，该类的签名如下：</p><blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobin</span> </span>{}  </span><br></pre></td></tr></tbody></table></figure></blockquote><p>然后还有一些类属性：</p><blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器群的ip地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; ips;</span><br><span class="line"><span class="comment">// 每台服务器对应的权值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; weight;</span><br><span class="line"><span class="comment">// 每台服务器的负载量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TreeMap&lt;String, Integer&gt; map;</span><br><span class="line"><span class="comment">// 服务器的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 打印服务器的ip地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getIps</span><span class="params">()</span></span>{}</span><br><span class="line"><span class="comment">// 模仿负载均衡算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBalancing</span><span class="params">(<span class="keyword">int</span> req)</span></span>{}</span><br><span class="line"><span class="comment">// 打印每台服务器的负载量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getServerChargeNumber</span><span class="params">()</span></span>{}</span><br></pre></td></tr></tbody></table></figure></blockquote><p>最重要的就是负载均衡算法方法了，我们先来看一下是如何实现的</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBalancing</span><span class="params">(<span class="keyword">int</span> req)</span> </span>{    </span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span> (req &gt; <span class="number">0</span>){     </span><br><span class="line">        <span class="comment">// 当pos轮询到最后一台服务器的时候，又从0开始轮询</span></span><br><span class="line">        <span class="keyword">if</span> (pos == count) pos = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">// 当前转发的服务器ip地址</span></span><br><span class="line">        String currServerIp = ips.get(pos);</span><br><span class="line">        <span class="comment">// 当前权值</span></span><br><span class="line">        <span class="keyword">int</span> currServerWeight = weight.get(pos);        </span><br><span class="line">        <span class="comment">/**         </span></span><br><span class="line"><span class="comment">        * 如果当前服务器的权为5的话，必须给当前服务器分配5个请求才能给下一份服务器分配         </span></span><br><span class="line"><span class="comment">        */</span>        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> currServerChargeNumber = <span class="number">0</span>;currServerChargeNumber &lt;= currServerWeight; ++currServerChargeNumber){          </span><br><span class="line">            <span class="comment">// 模拟转发请求。这里记录一下服务器收到的请求数</span></span><br><span class="line">            map.put(currServerIp, map.get(currServerIp) + <span class="number">1</span>);            </span><br><span class="line">            <span class="comment">// 请求减一</span></span><br><span class="line">            req--;        </span><br><span class="line">        }        </span><br><span class="line">        <span class="comment">// 对应加一</span></span><br><span class="line">        pos++;    </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实加权轮询法比轮询法多加了一个权值而已，假如我们有三台服务器，有10个ip发来请求，这三台服务器的权值分别为5， 3， 2，根据权值大小，第一台服务器要处理5个请求，在轮询到下一个服务器，第二台就要处理3个请求，接下来第三台肯定就要处理两个请求了，就这样我们才能做到真正的负载均衡。根据服务器的硬件性能分配不同的权值，在根据权值大小去分配请求。</p><p>多说无益，我们直接模拟发起请求吧。</p><p>先看完整的算法代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.round_robin;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobin</span> </span>{    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; ips;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; weight;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeMap&lt;String, Integer&gt; map;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;    </span><br><span class="line">    <span class="keyword">static</span> {        </span><br><span class="line">        <span class="comment">// 初始化 ip地址        </span></span><br><span class="line">        ips = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line">        map = <span class="keyword">new</span> TreeMap&lt;&gt;();        </span><br><span class="line">        weight = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line">        count = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) {            </span><br><span class="line">            String ip = <span class="string">"192.168.1."</span> + i;                               ips.add(ip);            </span><br><span class="line">            map.put(ip, <span class="number">0</span>);            </span><br><span class="line">            count++;        </span><br><span class="line">        }        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; --i)                                    weight.add(i);    </span><br><span class="line">    }    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoundRobin</span><span class="params">()</span> </span>{}    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getIps</span><span class="params">()</span> </span>{        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) {            </span><br><span class="line">            System.out.println(<span class="string">"ip:"</span> + ips.get(i) + <span class="string">" 权重:"</span> + weight.get(i));        </span><br><span class="line">        }    </span><br><span class="line">    }    </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> req 向请求服务器发起请求次数    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回代理的ip地址    </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBalancing</span><span class="params">(<span class="keyword">int</span> req)</span> </span>{        </span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">while</span> (req &gt; <span class="number">0</span>){            </span><br><span class="line">            <span class="keyword">if</span> (pos == count) pos = <span class="number">0</span>;            </span><br><span class="line">            String currServerIp = ips.get(pos);            </span><br><span class="line">            <span class="keyword">int</span> currServerWeight = weight.get(pos);            </span><br><span class="line">            <span class="comment">/**            </span></span><br><span class="line"><span class="comment">            * 如果当前服务器的权为5的话，必须给当前服务器分配5个请求才能给下一份服务器分配             </span></span><br><span class="line"><span class="comment">            */</span>            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> currServerChargeNumber = <span class="number">0</span>; currServerChargeNumber &lt;= currServerWeight; ++currServerChargeNumber) {                </span><br><span class="line">                map.put(currServerIp, map.get(currServerIp) + <span class="number">1</span>);                </span><br><span class="line">                req--;            </span><br><span class="line">            }            </span><br><span class="line">            pos++;        </span><br><span class="line">        }    </span><br><span class="line">    }    </span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 打印每台服务器的负载量     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getServerChargeNumber</span><span class="params">()</span> </span>{        </span><br><span class="line">        Set&lt;String&gt; set = map.keySet();        </span><br><span class="line">        <span class="keyword">for</span> (String ip : set)            </span><br><span class="line">            System.out.println(ip + <span class="string">" : "</span> + map.get(ip));   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码较长，其实自己写一遍更好理解。</p><p>模拟发起请求就放在主函数了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{        </span><br><span class="line">        RoundRobin roundRobin = <span class="keyword">new</span> RoundRobin();\</span><br><span class="line">        <span class="comment">// roundRobin.getIps();         </span></span><br><span class="line">        <span class="comment">// 模拟发起10000次请求</span></span><br><span class="line">        roundRobin.loadBalancing(<span class="number">10000</span>);                            roundRobin.getServerChargeNumber();    </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每台服务器处理的请求如下：</p><blockquote><p>192.168.1.1 : 1860</p><p>192.168.1.2 : 1665</p><p>192.168.1.3 : 1480</p><p>192.168.1.4 : 1295</p><p>192.168.1.5 : 1110</p><p>192.168.1.6 : 925</p><p>192.168.1.7 : 740</p><p>192.168.1.8 : 555</p><p>192.168.1.9 : 370</p></blockquote><p>ok，很简单吧，是不是瞬间感觉自己也能开发出一台服务器了。哈哈哈，不过正式服务器内部代码肯定不像我这样，还要处理客户端发来的数据，还要检测每台服务器是否能够正常通讯，总之神功不是一天就练成了，了解其内部处理原理才能够帮助我们写出更好的代码。</p><p>加油吧骚年！！！</p><h1 id="fq软件"><a href="#fq软件" class="headerlink" title="fq软件"></a>fq软件</h1><p>链接：<a href="https://pan.baidu.com/s/1ujgOh_EGhyUakAOCBEIgDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1ujgOh_EGhyUakAOCBEIgDA</a> 提取码：ydi7</p><blockquote><p>如何使用就自己琢磨了。可以自己搭建ssr，也可以上网买ssr，我只提供软件而已</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;没想到我也是一个标题党&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;去年，利用业余时间以及所学知识建
      
    
    </summary>
    
    
      <category term="服务器" scheme="https://NonCover.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="nginx" scheme="https://NonCover.github.io/tags/nginx/"/>
    
      <category term="负载均衡" scheme="https://NonCover.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的求平方根</title>
    <link href="https://noncover.github.io/2020/05/10/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>https://noncover.github.io/2020/05/10/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/</id>
    <published>2020-05-10T09:25:23.000Z</published>
    <updated>2020-05-10T09:26:16.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="F-amp-Q"><a href="#F-amp-Q" class="headerlink" title="F&amp;Q"></a>F&amp;Q</h1><p>承太郎：DIO，来做一道题</p><p>DIO：承太郎。来吧。（JOJO立）</p><p>承太郎：求一个数的算术平方根，保留整数部分，简单吧，你一定很快就能做出来。</p><p>DIO：Math.sqrt(x)，太简单了。hahaha</p><p>承太郎：你居然说用Math.sqrt()，不能用库函数！！！不能用库函数！！！不能用库函数！！！やれやれだぜ（真是够了），</p><p>DIO：这！！砸瓦鲁多!!</p><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><p>求一个正整数的算术平方根的话，这个平方根一定不会大于这个正整数的二分之一。所以我们可以利用二分法从区间[1，x / 2]中来找这个平方根</p><p>关于二分搜索查考这篇文章：<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="comment">// 二分法</span></span><br><span class="line">        <span class="comment">// 0的任何次方等于0</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">long</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 不考虑越界</span></span><br><span class="line">            <span class="keyword">long</span> v = mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (v &gt; x) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)left;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>值得注意的是取mid这里，我们一定要取区间的右中位数，例如求9的平方根，当我们计算到区间【3， 4】的话，如果mid按照如下取值的话</p><blockquote><p>mid = left + (right - left ) / 2</p></blockquote><p>此时，mid=3，left = mid，此时会循环查找【3，4】的值。</p><h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><p>重点来了，这道题更牛逼的算法还是牛顿迭代法（万能的牛顿，你还有啥不会的），其实准确的叫牛顿-拉夫逊（拉弗森）方法，又是一个被牛顿名声盖过的人，可怜拉弗森一秒钟。。。。</p><p>好了。在这里我不讲牛顿迭代法如何得来，反正从泰勒级数展开公式推导出的，说了你也不懂（皮一下），我就从结论入手。</p><p>先看一图：</p><p>​        <img src="https://img-blog.csdn.net/20160721095700588" alt="牛顿法动图"></p><p>该算法的思想是：</p><blockquote><p>  迭代的过程中，使x不停的逼近与 f(x)=0，直到迭代收敛，上图不难看出来</p></blockquote><p>因为牛顿法（下面会给出证明链接），所以我们可以令f(x) = x^2 - c</p><p>得出，x点切线方程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/10/twdvvj.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>变形可得：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/10/1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>又令f(x) = 0</p><p>所以得：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/10/2.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>所以：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/10/3.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>化简得出：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/10/4.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>那么，公式推导到此结束，剩下的就该写代码了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> v = x;</span><br><span class="line">        <span class="keyword">while</span> (v * v &gt; x)</span><br><span class="line">            v = (v + x / v) / <span class="number">2</span>;  <span class="comment">// 公式</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)v;  <span class="comment">// 取整</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img src="http://lock2016.xyz/media/upload/NonCover/2020/05/10/bgsmkd.jpg" alt="img"></p><p>当然，如果我们不取整的话，只需要把long变成double型，注意有些数的算术平方根是算不出的，我们需要一个变量来保存上一步求出的数，用当前的数减去上一步求出的数 小于 <strong>一个精度</strong> 即可。</p><p>看代码吧，我相信我的写作功底不是太好（留下了没有技术的泪）。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v 0.0000001</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">double</span> pre = <span class="number">0</span>;<span class="comment">// 上一步算的</span></span><br><span class="line"><span class="keyword">double</span> curr = x;<span class="comment">// 当前算的</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">abs</span>(curr - pre) &gt; v)</span><br><span class="line">{</span><br><span class="line">pre = curr;</span><br><span class="line">curr = (curr + x / curr) / <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输入：5</p><p>输出：2.23607</p></blockquote><p>如果要求精度越高，我们只需要改变v的值就行了。</p><h1 id="F-amp-Q-1"><a href="#F-amp-Q-1" class="headerlink" title="F&amp;Q"></a>F&amp;Q</h1><p>承太郎：好吧，算你厉害。如果你用替身攻击，当我没说。</p><p>DIO：嘿嘿</p><p>承太郎：对了你这些公式是怎么搞出来的。</p><p>DIO：推荐你一个在线绘制公式的网站吧：<a href="http://www.wiris.com/editor/demo/en/developers" target="_blank" rel="noopener">http://www.wiris.com/editor/demo/en/developers</a></p><p>承太郎：很赞。</p><p>承太郎：你为啥一会用java写代码，一会儿用cpp、python</p><p>DIO：全凭喜好，语言不重要，重要的是思想，哪个语言表达的逻辑清晰就用那个，不过我平时还是写Java和Python。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://search.bilibili.com/all?keyword=jojo&amp;from_source=nav_suggest_new" target="_blank" rel="noopener">《JoJo的奇妙冒险》</a></p><p><a href="https://www.zhihu.com/question/20690553" target="_blank" rel="noopener">《如何通俗易懂地讲解牛顿迭代法求开方？数值分析？》</a></p><p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">力扣</a></p><p><a href="https://blog.csdn.net/batuwuhanpei/article/details/51979831" target="_blank" rel="noopener">csdn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;F-amp-Q&quot;&gt;&lt;a href=&quot;#F-amp-Q&quot; class=&quot;headerlink&quot; title=&quot;F&amp;amp;Q&quot;&gt;&lt;/a&gt;F&amp;amp;Q&lt;/h1&gt;&lt;p&gt;承太郎：DIO，来做一道题&lt;/p&gt;
&lt;p&gt;DIO：承太郎。来吧。（JOJO立）&lt;/p&gt;
&lt;p&gt;承太郎
      
    
    </summary>
    
    
      <category term="算法" scheme="https://NonCover.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="https://NonCover.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分法" scheme="https://NonCover.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣5406收集树上所有苹果的最少时间</title>
    <link href="https://noncover.github.io/2020/05/10/%E5%8A%9B%E6%89%A35406%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%8A%E6%89%80%E6%9C%89%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/"/>
    <id>https://noncover.github.io/2020/05/10/%E5%8A%9B%E6%89%A35406%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%8A%E6%89%80%E6%9C%89%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</id>
    <published>2020-05-10T06:29:08.000Z</published>
    <updated>2020-05-10T06:32:05.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="废话先说"><a href="#废话先说" class="headerlink" title="废话先说"></a>废话先说</h1><p>今天本来是不想打周赛的，手贱不小心报名了（其实还是想去打），前两题不说了，都是很简单的题。直到遇到第三题，我停下了手，开始不断尝试各种方法，</p><p>直到比赛结束我也没有完成，看了各路大神的解法后，才知道我是有多菜鸡。</p><p>前两题：<a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">形成两个异或相等数组的三元组数目</a>和<a href="https://leetcode-cn.com/problems/build-an-array-with-stack-operations/" target="_blank" rel="noopener">用栈操作构建数组</a>，第四题我一般直接放弃，除非第四题不难（那是不可能的）。</p><p>本周周赛才完成两道题。成绩惨不忍睹，以后还是乖乖打周赛算了。看着大神十几分钟做完四道题，我还得努力才是。</p><h1 id="收集树上所有苹果的最少时间（点击标题，查看题目页）"><a href="#收集树上所有苹果的最少时间（点击标题，查看题目页）" class="headerlink" title="收集树上所有苹果的最少时间（点击标题，查看题目页）"></a><a href="https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree/" target="_blank" rel="noopener">收集树上所有苹果的最少时间</a>（点击标题，查看题目页）</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>给你一棵有 n 个节点的无向树，节点编号为 0 到 n-1 ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 节点 0 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</strong></p><p><strong>无向树的边由 edges 给出，其中 edges[i] = [fromi, toi] ，表示有一条边连接 from 和 toi 。除此以外，还有一个布尔数组 hasApple ，其中 hasApple[i] = true 代表节点 i 有一个苹果，否则，节点 i 没有苹果。</strong></p><p><strong>示例 1：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/10/min_time_collect_apple_1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p><strong>输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]<br>输出：8<br>解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。<br>示例 2：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/media/upload/NonCover/2020/05/10/min_time_collect_apple_2.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p><strong>输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]<br>输出：6<br>解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。<br>示例 3：</strong></p><p><strong>输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]<br>输出：0</strong></p><p><strong>提示：</strong></p><ul><li><strong>1 &lt;= n &lt;= 10^5</strong></li><li><strong>edges.length == n-1</strong></li><li><strong>edges[i].length == 2</strong></li><li><strong>0 &lt;= fromi, toi &lt;= n-1</strong></li><li><strong>fromi &lt; toi</strong></li><li><strong>hasApple.length == n</strong></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我看了题解后发现大佬们都有一下几个解题方法：</p><ol><li>不要从0节点出发，从是苹果的节点出发</li><li>无向树一定要转换成HashMap，这样能保证效率</li><li>没走过一条边，一定要用集合去重</li></ol><p>好了，总结完大佬们的思路，也该来说说我的观点了，其实这题一开始我确实想复杂了，题目要求的时，我们从节点0出发，去摘苹果，摘完所有苹果后，还得回到节点0，返回花费的最少时间，总而言之就是少走路。</p><p>如果一开始从0出发的话，很好，你成功被题目带偏，如果从0出发，你将有许多种选择，你还得判断选择的正确性，不错，一开始我就是这样做的，做难受的是即使是这种最直观的做法，我也没做出来。</p><p> <img src="http://img4.imgtn.bdimg.com/it/u=910568225,3325970999&amp;fm=26&amp;gp=0.jpg" alt="img"> </p><p>好吧，既然我无法去摘苹果，不如让苹果自动来让我摘（我可真机灵）。</p><p>总结思路如下：</p><ul><li>把edges转换成HashMap，key为当前节点，val为当前节点的父节点</li><li>用一个列表来保存苹果的节点</li><li>遍历苹果节点，利用HashMap找出从苹果节点到根节点（0），并且每经过一条变记得加入到集合中去重</li></ul><h2 id="代码（Java）"><a href="#代码（Java）" class="headerlink" title="代码（Java）"></a>代码（Java）</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, List&lt;Boolean&gt; hasApple)</span> </span>{</span><br><span class="line">        <span class="comment">// 存放当前节点的父节点</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存经过的节点</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] e: edges) map.put(e[<span class="number">1</span>], e[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 存放苹果节点</span></span><br><span class="line">        List&lt;Integer&gt; apple = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (hasApple.get(i))</span><br><span class="line">                apple.add(i);</span><br><span class="line">        <span class="comment">// 没有苹果</span></span><br><span class="line">        <span class="keyword">if</span> (apple.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// ans存放的是需要经过的节点数</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; apple.size(); ++i) {</span><br><span class="line">            <span class="keyword">int</span> tmp = apple.get(i);</span><br><span class="line">            set.add(tmp);</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="number">0</span>) {</span><br><span class="line">                tmp = map.get(tmp);</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(tmp)) {</span><br><span class="line">                    set.add(tmp);</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 为什么减一</span></span><br><span class="line">        <span class="comment">// ans存放的是需要经过的节点数，ans - 1才是经过的边的数</span></span><br><span class="line">        <span class="keyword">return</span> (ans - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>某位大佬的做法O（N）的时间复杂度也能完成。</p><p>》》》》》传送门：<a href="https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solution/biao-ji-qi-xing-dai-ma-by-lawskivsky/" target="_blank" rel="noopener">这位大佬</a>《《《《《</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;废话先说&quot;&gt;&lt;a href=&quot;#废话先说&quot; class=&quot;headerlink&quot; title=&quot;废话先说&quot;&gt;&lt;/a&gt;废话先说&lt;/h1&gt;&lt;p&gt;今天本来是不想打周赛的，手贱不小心报名了（其实还是想去打），前两题不说了，都是很简单的题。直到遇到第三题，我停下了手，开始不
      
    
    </summary>
    
    
      <category term="力扣" scheme="https://NonCover.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="无向树" scheme="https://NonCover.github.io/tags/%E6%97%A0%E5%90%91%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://NonCover.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的进行幂计算</title>
    <link href="https://noncover.github.io/2020/05/08/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8C%E5%B9%82%E8%AE%A1%E7%AE%97/"/>
    <id>https://noncover.github.io/2020/05/08/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8C%E5%B9%82%E8%AE%A1%E7%AE%97/</id>
    <published>2020-05-08T03:39:20.000Z</published>
    <updated>2020-05-08T03:40:23.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h1><p>幂计算最简单也最容易想到的算法当然是朴素算法了，不说了，直接看代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (m &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">ans *= n;</span><br><span class="line">m--;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度：O（n）</p><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>快速幂其实就是用了二分的思想，我们来看 2^10如何计算的</p><p>2^10 = 2 ^ 5 x 2 ^ 5 = 32 x 32 =1024</p><p>2 ^ 5 = 2 ^ 2 x 2 ^ 2 x 2 = 4 x 4 x 2 = 32</p><p>2 ^ 2 = 2 x 2 = 4</p><p>当然，我们遇到幂为奇数的时候，就用一个变量来保存答案</p><p>当计算10次方的时候，我们也只计算了3次，算法复杂度从 O(n) 下降到了 O(log2n)</p><p>整理思路如下步骤；</p><p>\1. 把幂对半分</p><p>\2. 遇到幂为奇数时，就更新答案</p><p>\3. 幂直到为0，就返回答案</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = n;</span><br><span class="line"><span class="keyword">while</span> (m &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (m &amp; <span class="number">1</span>) ans *= tmp;</span><br><span class="line">tmp *= tmp;</span><br><span class="line">m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>需要注意的是，当幂很大时，我们会造成整形溢出，所以一般用 long或者long long的数据类型</strong></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;朴素算法&quot;&gt;&lt;a href=&quot;#朴素算法&quot; class=&quot;headerlink&quot; title=&quot;朴素算法&quot;&gt;&lt;/a&gt;朴素算法&lt;/h1&gt;&lt;p&gt;幂计算最简单也最容易想到的算法当然是朴素算法了，不说了，直接看代码&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
    
      <category term="算法" scheme="https://NonCover.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="https://NonCover.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="快速幂" scheme="https://NonCover.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>非递归遍历二叉树</title>
    <link href="https://noncover.github.io/2020/05/05/%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://noncover.github.io/2020/05/05/%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-05-05T06:29:12.000Z</published>
    <updated>2020-05-05T06:30:20.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在力扣做题时，看见了用前中后的方式来遍历二叉树的节点，不弱题目要求的是用非递归的形式来求解，不过以前我写的是用递归方式。所以在这儿做个笔记。</p><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/static/ckeditor/ckeditor/plugins/smiley/images/wink_smile.png" alt="wink" title="">                </div>                <div class="image-caption">wink</div>            </figure></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实思路很简单，回想递归法，我们每次先依次遍历左字树，再右子树，当前节点存在的话，我们就打印出当前节点，然后继续递归左右子树。非递归法也差不多，不过我们需要用栈存放每个节点，每次迭代时，取出栈顶元素即可，注意我们这里，入栈时是先入右子树 再是 左子树，因为我们栈的特点是先进后出，所以要后方左子树</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dlr</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">"""前序遍历"""</span></span><br><span class="line">    ans = []</span><br><span class="line">    st = []  <span class="comment">## 栈</span></span><br><span class="line">    <span class="keyword">if</span> root: st.append(root)</span><br><span class="line">    <span class="keyword">while</span> st:</span><br><span class="line">        node = st.pop()</span><br><span class="line">        ans.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.right: st.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left: st.append(node.left)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/static/ckeditor/ckeditor/plugins/smiley/images/confused_smile.png" alt="frown" title="">                </div>                <div class="image-caption">frown</div>            </figure></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>再回想递归法，我们是先递归左子树，直到为空时，我们再打印出节点，然后继续递归右子树。那么如何用迭代来打印出中序遍历的每一个节点，当然也要用到栈这一数据结构（Python直接用列表来模拟栈），我们需要curr这一指针来指向当前需要打印的节点，由于要先递归左子树，所以我们先要迭代出当前节点的所有左子树放入栈当中去，直到为空后，我们再取出栈顶元素，最后我们curr指针指向当前栈顶元素的右子树，继续迭代。</p><ol><li>迭代curr指针指向节点的左子树放入栈中，直到节点为空</li><li>打印栈顶节点，更新curr指针到当前打印节点的右子树</li><li>重复1，2步，直到栈为空</li></ol><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ldr</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">"""中序遍历"""</span></span><br><span class="line">    ans = []</span><br><span class="line">    st = []</span><br><span class="line">    curr = root</span><br><span class="line">    <span class="keyword">while</span> curr <span class="keyword">or</span> st:</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            st.append(curr)</span><br><span class="line">            curr = curr.left</span><br><span class="line">        curr = st.pop()</span><br><span class="line">        ans.append(curr.val)</span><br><span class="line">        curr = curr.right</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://lock2016.xyz/static/ckeditor/ckeditor/plugins/smiley/images/shades_smile.png" alt="cool" title="">                </div>                <div class="image-caption">cool</div>            </figure></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>和前序遍历差不多，交换前序遍历代码中的9，10行代码。注意我们每次打印每个节点，需要将每个节点值插入到结果数组的首位。这是因为我们其实每次取元素时，是按照二叉树从上到下，从右到左来取的，所以只需要把结果数组倒转来，从下到上、从左到右即可。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lrd</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">"""后序遍历"""</span></span><br><span class="line">    ans = []</span><br><span class="line">    st = []</span><br><span class="line">    <span class="keyword">if</span> root: st.append(root)</span><br><span class="line">    <span class="keyword">while</span> st:</span><br><span class="line">        node = st.pop()</span><br><span class="line">        ans.insert(<span class="number">0</span>, node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left: st.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right: st.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天在力扣做题时，看见了用前中后的方式来遍历二叉树的节点，不弱题目要求的是用非递归的形式来求解，不过以前我写的是用递归方式。所以在这儿做个笔
      
    
    </summary>
    
    
      <category term="算法" scheme="https://NonCover.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://NonCover.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://NonCover.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="迭代法" scheme="https://NonCover.github.io/tags/%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>桶排序</title>
    <link href="https://noncover.github.io/2020/04/28/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://noncover.github.io/2020/04/28/%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-28T12:09:15.000Z</published>
    <updated>2020-04-28T12:15:24.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="桶排序最简单最快的排序方法"><a href="#桶排序最简单最快的排序方法" class="headerlink" title="桶排序最简单最快的排序方法"></a>桶排序最简单最快的排序方法</h2><h2 id="假定有五个人，他们身上分别由，-5，-3，-1，-5，-7元钱，那么我们如何将这五个从小到大来排序？"><a href="#假定有五个人，他们身上分别由，-5，-3，-1，-5，-7元钱，那么我们如何将这五个从小到大来排序？" class="headerlink" title="假定有五个人，他们身上分别由， 5， 3， 1， 5， 7元钱，那么我们如何将这五个从小到大来排序？"></a>假定有五个人，他们身上分别由， 5， 3， 1， 5， 7元钱，那么我们如何将这五个从小到大来排序？</h2><h2 id="没错，我们要实现这个算法就要用到最简单，最快的一种排序方式——计数排序，所用到的算法思想来自于桶排序"><a href="#没错，我们要实现这个算法就要用到最简单，最快的一种排序方式——计数排序，所用到的算法思想来自于桶排序" class="headerlink" title="没错，我们要实现这个算法就要用到最简单，最快的一种排序方式——计数排序，所用到的算法思想来自于桶排序"></a>没错，我们要实现这个算法就要用到最简单，最快的一种排序方式——计数排序，所用到的算法思想来自于桶排序</h2><p>核心思想就离不开这个桶字。</p><p>假设我们面前有10个桶，我们可以把它看作一个内存空间为10的数组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arrs[10]; // 代表10个桶</span><br></pre></td></tr></tbody></table></figure><p>我们将这10个桶编号从 a[0] –&gt; a[9]，并且从一开始这10个桶里什么东西都没有，视为0</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 初始化数组为0</span><br><span class="line">for (int i = 0; i &lt;= 10; i++)</span><br><span class="line">{</span><br><span class="line">    a[i] = 0; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/1.8.png" alt="img"></p><p>网络图片</p><p>然后，我们依次读取这五个人身上所带的钱。</p><p>有5元钱的，桶编号为5记录一次，</p><p>带3元钱的，编号为3的痛记录一次，</p><p>由于有两个人带了5元钱，所以记录两次。</p><p>依次对这五个人进行记录</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] people = {5, 4, 1, 5, 7};</span><br><span class="line">for (auto i : people)</span><br><span class="line">{</span><br><span class="line">arrs[i]++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>记录完后，我们需要将这五个人带的钱的多少从大到小打印出来</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt;= 10; i++)</span><br><span class="line">{</span><br><span class="line">    while(arrs[i]!=0) </span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; " ";</span><br><span class="line">        arrs[i]--;  // 输出完后减一</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就会打印出 这五个人从小到大排序后的值。</p><p>完整代码如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int people[5] = {5, 3, 1, 5, 7};</span><br><span class="line">    int buckets[10];    // 定义桶</span><br><span class="line">    for (int i = 0; i &lt;= 10; i++) </span><br><span class="line">    { //1. 初始化桶</span><br><span class="line">        buckets[i] = 0;</span><br><span class="line">    }</span><br><span class="line">    for (auto i : people)</span><br><span class="line">    { //2. 记录</span><br><span class="line">        buckets[i]++;</span><br><span class="line">    }</span><br><span class="line">    for (int i = 0; i &lt;= 10; i++)</span><br><span class="line">    { //3. 打印</span><br><span class="line">        while (buckets[i] != 0)</span><br><span class="line">        {</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; " ";</span><br><span class="line">            buckets[i]--;  // 输出完后减一</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果想要从大到小排序，只需要将第3步的循环倒叙遍历即可。</p><p>当然这并不是桶排序，真正的桶排序比这复杂的多，只是用到了桶排序的一种思想而已。<br>时间复杂度O（M+N），对于空间复杂度这里便不说，这场战役只成功一半。</p><hr><p>新手练习写Blog，有错请指教</p><hr><p>output：1 3 5 5 7</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;桶排序最简单最快的排序方法&quot;&gt;&lt;a href=&quot;#桶排序最简单最快的排序方法&quot; class=&quot;headerlink&quot; title=&quot;桶排序最简单最快的排序方法&quot;&gt;&lt;/a&gt;桶排序最简单最快的排序方法&lt;/h2&gt;&lt;h2 id=&quot;假定有五个人，他们身上分别由，-5，-3，
      
    
    </summary>
    
    
      <category term="算法" scheme="https://NonCover.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://NonCover.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>约瑟夫环问题</title>
    <link href="https://noncover.github.io/2020/04/27/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
    <id>https://noncover.github.io/2020/04/27/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-27T12:23:55.000Z</published>
    <updated>2020-04-27T12:26:15.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是约瑟夫环？"><a href="#什么是约瑟夫环？" class="headerlink" title="什么是约瑟夫环？"></a>什么是<a href="https://baike.baidu.com/item/约瑟夫问题/3857719?fr=aladdin" target="_blank" rel="noopener">约瑟夫环</a>？</h1><p>先来简单说一下今天的这一道力扣打卡题|。</p><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>当然，我一开始最先想到的解法是模拟删除每一个节点，然后当剩下最后一个节点时就返回 答案。这是最容易也是最简单的一种做法。</p><blockquote><p>arr = [i for i in n]   # 用一个数组来保存这个圆圈的值</p></blockquote><p>​       <img src="http://lock2016.xyz/media/upload/NonCover/2020/03/30/image_kc9mBqN.png" alt="img"></p><p>我们先来思考一下，每次我们删除第3个数</p><p>第一次删除的是 arr[m - 1]  = 2，</p><p>当然我们每一次的删除是基于上一次删除的数 <strong>+3 - 1</strong> 并对当前数组的长度取模才是我们真正需要删除的值。</p><p>代码可以写成：</p><blockquote><p>arr.pop((idx + 3 - 1 ) % len(arr))  # idx是上一次删除的数 </p></blockquote><p>​     <img src="http://lock2016.xyz/media/upload/NonCover/2020/03/30/image_VOARrUM.png" alt="img"></p><p><img src="http://lock2016.xyz/media/upload/NonCover/2020/03/30/image_VGLluX2.png" alt="img"></p><p>完整代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        circle = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            idx += m - <span class="number">1</span></span><br><span class="line">            idx %= len(circle)</span><br><span class="line">            circle.pop(idx)</span><br><span class="line">        <span class="keyword">return</span> circle[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度：O（n） </p><p>空间复杂度：O（n）</p><h1 id="是否可以优化？"><a href="#是否可以优化？" class="headerlink" title="是否可以优化？"></a>是否可以优化？</h1><p>观察如上代码，我们返回的值是circle[0]，因为我们最后只会删除到只剩一个值，那么这个值的位置肯定在数组第0个。</p><p>​    <img src="http://lock2016.xyz/media/upload/NonCover/2020/03/30/image_Zx2OzCD.png" alt="img"></p><p>观察这张图，我们是否可以通过数组下标0反推到答案3。</p><p>我们试着来推一下。</p><p>我们用 ret 来保存最终答案。其他变量不变</p><p>ret = 0</p><p>第一次反推：ret = 0， ret = (ret + 3) % 2 = 1  </p><p>第二次反推：ret = 1， ret = (ret + 3) % 3 = 1</p><p>第三次反推：ret = 1， ret = (ret + 3) % 4 = 0</p><p>第四次反推：ret = 0， ret = (ret + 3) % 4 = 3</p><p>所以我们从2开始反推到 n + 1次 即可得出最后答案</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            ret = (ret + m) % i         <span class="comment"># 反推公式，每次我们删除的数是上一次删除数在数 3个，那么我们 +3 在对当前数组取模就是上一次的位置。</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></tbody></table></figure><p>空间复杂度可以优化到 O（1）</p><p>练习写博客ing，记录每一次收获</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是约瑟夫环？&quot;&gt;&lt;a href=&quot;#什么是约瑟夫环？&quot; class=&quot;headerlink&quot; title=&quot;什么是约瑟夫环？&quot;&gt;&lt;/a&gt;什么是&lt;a href=&quot;https://baike.baidu.com/item/约瑟夫问题/3857719?fr=alad
      
    
    </summary>
    
    
      <category term="算法" scheme="https://NonCover.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="https://NonCover.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表的中点节点simple</title>
    <link href="https://noncover.github.io/2020/04/27/%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E7%82%B9%E8%8A%82%E7%82%B9simple/"/>
    <id>https://noncover.github.io/2020/04/27/%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E7%82%B9%E8%8A%82%E7%82%B9simple/</id>
    <published>2020-04-27T12:09:58.000Z</published>
    <updated>2020-04-27T12:27:00.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快慢指针遍历链表："><a href="#快慢指针遍历链表：" class="headerlink" title="快慢指针遍历链表："></a>快慢指针遍历链表：</h1><p> 因为我们所要返回此链表的中间节点。所以我们要用slow和fast来遍历链表，同时要做到slow所指向的节点始终在头节点到fast节点的中间节点，所以我们要每当slow移动一次的时候，fast要移动两次。当fast指向一个空节点的时候，就返回slow。 </p><p>Python代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x = None)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arr2List</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment"># 将数组转换成链表</span></span><br><span class="line">    head = ListNode()</span><br><span class="line">    node = ListNode()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head.val:</span><br><span class="line">            node = ListNode(i)</span><br><span class="line">            head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.next = ListNode(i)</span><br><span class="line">            node = node.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    head = arr2List(arr)</span><br><span class="line">    out = Solution().middleNode(head)</span><br><span class="line">    print(out.val)</span><br><span class="line"><span class="comment"># 时间复杂度：O（N）</span></span><br><span class="line"><span class="comment"># 空间复杂度：O（1）</span></span><br></pre></td></tr></tbody></table></figure><hr><img src="img\avatar.jpg" alt="rm-bg" style="zoom: 25%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      随便搬点东西
    
    </summary>
    
    
      <category term="算法" scheme="https://NonCover.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="https://NonCover.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="指针" scheme="https://NonCover.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>不正式的文章</title>
    <link href="https://noncover.github.io/2020/04/24/%E4%B8%8D%E6%AD%A3%E5%BC%8F%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>https://noncover.github.io/2020/04/24/%E4%B8%8D%E6%AD%A3%E5%BC%8F%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2020-04-24T13:18:10.000Z</published>
    <updated>2020-04-24T14:20:04.244Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="虽然没啥人看"><a href="#虽然没啥人看" class="headerlink" title="虽然没啥人看"></a>虽然没啥人看</h1><h1 id="关于blog"><a href="#关于blog" class="headerlink" title="关于blog"></a>关于blog</h1><ol><li>学习</li><li>记代码</li><li>偶尔写点算法题</li><li>装逼</li><li>来电色图</li></ol><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><ol><li>垃圾大学</li><li>程序员（个人比较偏后端（<strong>java、python</strong>）开发）</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>本人的其他网站（由于懒得维护，就放在哪了） -》》》》》 <a href="http://lock2016.xyz" target="_blank" rel="noopener" title="这儿">这儿</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;虽然没啥人看&quot;&gt;&lt;a href=&quot;#虽然没啥人看&quot; class=&quot;headerlink&quot; title=&quot;虽然没啥人看&quot;&gt;&lt;/a&gt;虽然没啥人看&lt;/h1&gt;&lt;h1 id=&quot;关于blog&quot;&gt;&lt;a href=&quot;#关于blog&quot; class
      
    
    </summary>
    
    
      <category term="随便写点" scheme="https://NonCover.github.io/categories/%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9/"/>
    
    
      <category term="一些话" scheme="https://NonCover.github.io/tags/%E4%B8%80%E4%BA%9B%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://noncover.github.io/2020/04/24/hello-world/"/>
    <id>https://noncover.github.io/2020/04/24/hello-world/</id>
    <published>2020-04-24T09:24:05.413Z</published>
    <updated>2020-04-24T09:24:05.413Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
